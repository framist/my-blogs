#! https://zhuanlan.zhihu.com/p/424679602
![操作系统概念题图](https://pic4.zhimg.com/80/v2-f32807e5e05705afefd424cf51e86885.png)

# 【操作系统概念-作业13】I/O Systems

# *Operating System Concepts* Exercises 13

<center>I/O Systems</center>

操作系统作业13

* 13.3, 13.4, 13.5
* 13.8, 13.9, 13.11, 13.12, 13.14

*每题最后一个引用块是老师提供的参考答案*

<!--more-->

## Practice Exercises

13.3, 13.4, 13.5

### 13.3 Why might a system use interrupt-driven I/O to manage a single serial port and polling I/O to manage a front-end processor, such as a terminal concentrator?

为什么一个系统可能使用中断驱动的I/O来管理一个单一的串行端口，而使用轮询I/O来管理一个前端处理器，如终端集中器？

**答：**

因事制宜。

> *Polling can be more efficient than interrupt-driven I/O. This is the case when the I/O is frequent and of short duration.* Even though a single serial port will perform I/O relatively infrequently and should thus use interrupts, a collection of serial ports such as those in a terminal concentrator can produce a lot of short I/O operations, and interrupting for each one could create a heavy load on the system. A well-timed polling loop could alleviate that load without wasting many resources through looping with no I/O needed.
>
> *轮询可能比中断驱动的I/O更有效。当I/O频繁且持续时间较短时，就会出现这种情况*。即使一个单一的串口会相对不频繁地执行I/O，因此应该使用中断，但一个串口的集合，如终端集中器中的串口，会产生大量的短时I/O操作，为每个串口进行中断会给系统带来沉重的负担。一个适时的轮询循环可以减轻这种负载，而不需要在没有I/O的情况下通过循环浪费很多资源。

### 13.4 Polling for an I/O completion can waste a large number of CPU cycles if the processor iterates a busy-waiting loop many times before the I/O completes. But if the I/O device is ready for service, polling can be much more efficient than is catching and dispatching an interrupt. Describe a hybrid strategy that combines polling, sleeping, and interrupts for I/O device service. For each of these three strategies (pure polling, pure interrupts, hybrid), describe a computing environment in which that strategy is more efficient than is either of the others.

如果处理器在I/O完成之前多次迭代一个忙于等待的循环，轮询I/O的完成可能会浪费大量的CPU周期。但是如果I/O设备已经准备好了，轮询的效率要比捕捉和分配中断的效率高得多。描述一种混合策略，结合轮询、休眠和中断为I/O设备服务。对于这三种策略中的每一种（纯轮询、纯中断、混合），描述一种计算环境，在这种环境中，该策略比其他任何一种都更有效率。



**答：**

> A hybrid approach could switch between polling and interrupts depending on the length of the I/O operation wait. For example, we could poll and loop N times, and if the device is still busy at N+1, we could set an interrupt and sleep. This approach would avoid long busy-waiting cycles. This method would be best for very long or very short busy times. It would be inefficient it the I/O completes at N+T (where T is a small number of cycles) due to the overhead of polling plus setting up and catching interrupts.
>
> Pure polling is best with very short wait times. 
>
> Interrupts are best with known long wait times.
>
> 一个混合的方法可以根据I/O操作等待的长度在轮询和中断之间切换。例如，我们可以轮询并循环N次，如果设备在N+1时仍然很忙，我们可以设置一个中断并睡眠。这种方法可以避免长时间的忙碌等待周期。这种方法最适合于非常长或非常短的忙碌时间。如果I/O在N+T时完成（其中T是一个小的周期数），由于轮询加上设置和捕捉中断的开销，它的效率会很低。
> 纯粹的轮询在很短的等待时间内是最好的。
> 中断在已知的长等待时间下是最好的。



### 13.5 How does DMA increase system concurrency? How does it complicate hardware design?

DMA是如何提高系统并发性的？它是如何使硬件设计复杂化的？

**答：**

通过直接内存存取；窃取总线周期。

> DMA increases system concurrency by allowing the CPU to perform tasks while the DMA system transfers data via the system and memory buses. Hardware design is complicated because the DMA controller must be integrated into the system, and the system must allow the DMA controller to be a bus master. Cycle stealing may also be necessary to allow the CPU and DMA controller to share use of the memory bus.
>
> DMA通过允许CPU执行任务，同时DMA系统通过系统和内存总线传输数据来增加系统并发性。硬件设计很复杂，因为DMA控制器必须被集成到系统中，而且系统必须允许DMA控制器成为总线主站。为了让CPU和DMA控制器共享内存总线的使用，可能还需要进行周期窃取。

## Exercises

13.8, 13.9, 13.11, 13.12, 13.14

### 13.8 When multiple interrupts from different devices appear at about the same time, a priority scheme could be used to determine the order in which the interrupts would be serviced. Discuss what issues need to be considered in assigning priorities to different interrupts.

当来自不同设备的多个中断大约在同一时间出现时，可以用一个优先级方案来确定中断的服务顺序。讨论在给不同的中断分配优先级时需要考虑哪些问题。

**答：**

需要考虑各种各样的问题。

> A number of issues need to be considered in order to determine the priority scheme. 
>
> - Interrupts raised by devices should be given higher priority than traps generated by the user program; a device interrupt can therefore interrupt code used for handling system calls.
>
> - Second, interrupts that control devices might be given higher priority than interrupts that simply perform tasks such as copying data served up a device to user/kernel buffers, since such tasks can always be delayed. 
>
> - Third, devices that have real-time constraints on when its data is handled should be given higher priority than other devices. 
>
> - Also, devices that do not have any form of buffering for its data would have to be assigned higher priority since the data could be available only for a short period of time.
>
>  为了确定优先级方案，需要考虑一些问题。
>
> - 由设备引发的中断应该比由用户程序产生的陷阱有更高的优先权；因此，设备中断可以中断用于处理系统调用的代码。
>
> - 第二，控制设备的中断可能被赋予更高的优先级，而不是简单的执行任务的中断，例如将设备上的数据复制到用户/内核缓冲区，因为这样的任务总是可以被延迟。
>
> - 第三，对于那些对其数据处理时间有实时限制的设备，应该比其他设备有更高的优先权。
>
> - 另外，没有任何形式的数据缓冲的设备将不得不被分配更高的优先级，因为数据可能只在短时间内可用。

### 13.9 What are the advantages and disadvantages of supporting memory-mapped I/O to device control registers?

支持内存映射的I/O到设备控制寄存器的优缺点是什么？

**答：**

> The advantage of supporting memory-mapped I/O to device control registers is that it eliminates the need for special I/O instructions from the instruction set and therefore also does not require the enforcement of protection rules that prevent user programs from executing these I/O instructions. 
>
> The disadvantage is that the resulting flexibility needs to be handled with care; *the memory translation units need to ensure that the memory addresses associated with the device control registers are not accessible by user programs in order to ensure protection.*
>
> 支持设备控制寄存器的内存映射I/O的优点是，它不需要指令集中的特殊I/O指令，因此也不需要执行保护规则，防止用户程序执行这些I/O指令。
>
> 缺点是需要谨慎处理由此产生的灵活性；*内存转换单元需要确保与设备控制寄存器相关的内存地址不被用户程序访问，以确保保护。*



### 13.11 In most multi-programmed systems, user programs access memory through virtual addresses, while the operating system uses raw physical addresses to access memory. What are the implications of this design for the initiation of I/O operations by the user program and their execution by the operating system?

在大多数多程序系统中，用户程序通过虚拟地址访问内存，而操作系统使用原始物理地址来访问内存。这种设计对用户程序启动I/O操作和操作系统执行这些操作有什么影响？

**答：**

> The user program typically specifies a buffer for data to be transmitted to or from a device. This buffer exists in user space and is specified by a virtual address. The kernel needs to issue the I/O operation and needs to copy data between the user buffer and its own kernel buffer before or after the I/O operation. In order to access the user buffer, the kernel needs to translate the virtual address provided by the user program to the corresponding physical address within the context of the user program’s virtual address space. This translation is typically performed in software and therefore incurs overhead. 
>
> Also, if the user buffer is not currently present in physical memory, the corresponding page(s) need to obtained from the swap space. This operation might require careful handling and might delay the data copy operation.
>
> 用户程序通常指定一个缓冲区，用于向设备传输或从设备传输数据。这个缓冲区存在于用户空间，由一个虚拟地址指定。内核需要发出I/O操作，并需要在I/O操作之前或之后在用户缓冲区和它自己的内核缓冲区之间复制数据。为了访问用户缓冲区，内核需要将用户程序提供的虚拟地址转换为用户程序的虚拟地址空间内的相应物理地址。这种转换通常是在软件中进行的，因此会产生开销。
> 另外，如果用户缓冲区目前不在物理内存中，则需要从交换空间中获得相应的页面。这个操作可能需要仔细处理，并可能延迟数据复制的操作。

### 13.12 What are the various kinds of performance overhead associated with servicing an interrupt?

与服务中断有关的各种性能开销是什么？

**答：**

上下文切换的开销；流水线重启的开销。

> When an interrupt occurs the currently executing process is interrupted and its state is stored in the appropriate process control block. The interrupt service routine is then dispatched in order to deal with the interrupt. On completion of handling of the interrupt, the state of the process is restored and the process is resumed. Therefore, the performance overheads include **the cost of saving and restoring process state and the cost of flushing the instruction pipeline and restoring the instructions into the pipeline when the process is restarted.**
>
> 当一个中断发生时，当前执行的进程被中断，其状态被存储在适当的进程控制块中。然后，中断服务例程被分派，以处理中断。在完成对中断的处理后，进程的状态被恢复，进程被恢复。因此，性能开销包括**保存和恢复进程状态的费用，以及冲洗指令流水线和在进程重新启动时将指令恢复到流水线的费用**。



### 13.14 Typically, at the completion of a device I/O, a single interrupt is raised and appropriately handled by the host processor. In certain settings, however, the code that is to be executed at the completion of the I/O can be broken into two separate pieces. The first piece executes immediately after the I/O completes and schedules a second interrupt for the remaining piece of code to be executed at a later time. What is the purpose of using this strategy in the design of interrupt handlers?

通常情况下，在设备I/O完成时，会引发一个中断，并由主机处理器适当处理。然而，在某些情况下，在I/O完成时要执行的代码可以分成两个独立的部分。第一块在I/O完成后立即执行，并为剩余的代码片断安排第二个中断，在以后的时间执行。在中断处理程序的设计中使用这种策略的目的是什么？

**答：**

区分优先级获得更佳的处理方案。

> The purpose of this strategy is to ensure that *the most critical aspect of the interrupt handling code is performed first and the less critical portions of the code are delayed for the future*. For instance, when a device finishes an I/O operation, the device-control operations corresponding to declaring the device as no longer being busy are more important in order to issue future operations. However, the task of copying the data provided by the device to the appropriate user or kernel memory regions can be delayed for a future point when the CPU is idle. In such a scenario, a lower-priority interrupt handler is used to perform the copy operation.
>
> 这种策略的目的是确保*中断处理代码中最关键的部分首先被执行，而代码中不太关键的部分被推迟到未来*。例如，当一个设备完成一个I/O操作时，为了发出未来的操作，与宣布设备不再繁忙相对应的设备控制操作就比较重要。然而，将设备提供的数据复制到适当的用户或内核内存区域的任务可以推迟到未来CPU空闲时进行。在这种情况下，一个低优先级的中断处理程序被用来执行复制操作。


---

**注：**

翻译：deepl

参考资料：

[1] Operating System Concepts – 9th Edition 及其答案

