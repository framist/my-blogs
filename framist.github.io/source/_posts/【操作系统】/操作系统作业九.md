---
title: 【操作系统概念 - 作业 9】Virtual Memory
date: 2021-10-8
abbrlink: operating-system-concepts-exercise-9
categories:
  - 计算机科学
  - 课业学习
  - 操作系统
tags:
  - 操作系统
  - 学习
---

# *Operating System Concepts* Exercises 9

<center>Virtual Memory</center>

操作系统作业 9

* 9.1, 9.3, 9.4, 9.5, 9.7, 9.8
* 9.15, 9.18, 9.21, 9.22, 9.32, 9.34

*每题最后一个引用块是老师提供的参考答案*

<!--more-->

## Practice Exercises

9.1, 9.3, 9.4, 9.5, 9.7, 9.8


### 9.1 Under what circumstances do page faults occur? Describe the actions taken by the operating system when a page fault occurs.

在什么情况下会发生页面故障？描述一下当发生页面故障时，操作系统采取的行动。

**答：** 

发生缺页错误时。

操作系统进行调页。

> A page fault occurs whenever a process tries to access a page which is marked as invalid in the page table entry for that page. 
>
> A page fault generates an interrupt which invokes the operating system code in privileged mode. The OS then examines some internal table (usually kept with the process control block for this process) to determine if the page is on disk. If the page is on disk (i.e. it really is a valid memory reference) the operating system then allocates a free frame, starts the disk I/O to read the desired page into the newly allocated frame, and **starts the next process**.
>
> When the disk I/O is finished, the internal table kept with the process and page table are updated to indicate that the page is now in memory. The instruction that was interrupted by the illegal address trap is restarted. The process can now access the page as though it had always been in memory.
>
> 当一个进程试图访问一个在页表条目中被标记为无效的页时，就会发生页故障。
>
> 页面故障会产生一个中断，在特权模式下调用操作系统的代码。然后操作系统检查一些内部表（通常与该进程的进程控制块一起保存）以确定该页是否在磁盘上。如果该页在磁盘上（即它确实是一个有效的内存引用），操作系统就会分配一个空闲的帧，启动磁盘 I/O，将所需的页读入新分配的帧，并**启动下一个进程**。
>
> 当磁盘 I/O 完成后，与进程和页表一起保存的内部表被更新，以表明该页现在在内存中。被非法地址陷阱打断的指令被重新启动。该进程现在可以访问该页，就像它一直在内存中一样。

### 9.3 Consider the page table shown in Figure 9.30 for a system with 12-bit virtual and physical addresses and with 256-byte pages. The list of free page frames is D, E, F (that is, D is at the head of the list, E is second, and F is last).

考虑图 9.30 所示的页表，该系统有 12 位的虚拟和物理地址，有 256 字节的页。空闲页框的列表是 D，E，F（也就是说，D 在列表的头，E 在第二，F 在最后）。



![image-20210616125026470](http://framist-bucket-openread.oss-cn-shanghai.aliyuncs.com/img/2023/08/15/20230815203909.png)

<center>Figure 9.30 Page table for Exercise 9.3.</center>

Convert the following virtual addresses to their equivalent physical addresses in hexadecimal. All numbers are given in hexadecimal. (A dash for a page frame indicates that the page is not in memory.)

将下列虚拟地址转换为十六进制的对应物理地址。所有的数字都以十六进制给出。(一个页框的破折号表示该页不在内存中)。



#### 9EF

9EF -> 0EF 

#### 111

111 -> 211

#### 700

700 -> D00

#### 0FF

0FF -> EFF



> When page fault occurs, OS load the desired page into a frame assigned from the list of free page frames.
>
> 当页面故障发生时，操作系统将所需的页面加载到从空闲页面框架列表中指定的框架中。

### 9.4 Consider the following page-replacement algorithms. Rank these algorithms on a five-point scale from “bad” to “perfect” according to their page-fault rate. Separate those algorithms that suffer from Belady’s anomaly from those that do not.

考虑以下的页面替换算法。根据这些算法的页面错误率，在从 "糟糕 "到 "完美 "的五级评分中对其进行排名。把那些受到贝拉迪异常现象影响的算法和那些没有受到影响的算法分开。

#### a. LRU replacement 最近最久未使用置换算法（LRU）

:star::star::star::star:

not suffer from Belady’s anomaly

#### b. FIFO replacement 先进先出置换算法（FIFO）

:star:

suffer from Belady’s anomaly

#### c. Optimal replacement 最佳置换算法（OPT）

:star::star::star::star::star:

not suffer from Belady’s anomaly

#### d. Second-chance replacement

:star::star::star:

not suffer from Belady’s anomaly




### 9.5 Discuss the hardware support required to support demand paging.

讨论支持请求调页所需的硬件支持。

**答：** 

> For every memory-access operation, the page table needs to be consulted to check whether the corresponding page is resident in memory or not, and determine whether a page fault is triggered. These checks have to be performed in hardware (**MMU**). A TLB could serve as a cache and improve the performance of the lookup operation.
>
> 对于每个内存访问操作，都需要查询页表，以检查相应的页是否驻留在内存中，并确定是否触发了页故障。这些检查必须在硬件（**MMU**）中进行。一个 TLB 可以作为一个缓存，并提高查询操作的性能。





### 9.7 Consider the two-dimensional array A:

考虑二维数组 A：

`int A[][] = new int[100][100];`

where `A[0][0]` is at location 200 in a paged memory system with pages of size 200. A small process that manipulates the matrix resides in page 0 (locations 0 to 199). Thus, every instruction fetch will be from page 0. For three page frames, how many page faults are generated by the following array-initialization loops? Use LRU replacement, and assume that page frame 1 contains the process and the other two are initially empty.

其中`A[0][0]`在一个页大小为 200 的分页内存系统中位于位置 200。一个操作矩阵的小进程驻扎在第 0 页（位置 0 到 199）。因此，每条指令的获取都来自于第 0 页。对于三个页框，下面的数组初始化循环会产生多少个页面错误？使用 LRU 替换，并假设第 1 页包含进程，其他两个最初是空的。

**答：** 

> In this system, each page holds 50 integers (integer has a size of 4 bytes) and thus one row of A needs 2 pages and entire A needs 2 *100 = 200 pages.
>
> 在这个系统中，每页可以容纳 50 个整数（整数的大小为 4 字节），因此 A 的一行需要 2 页，整个 A 需要 2*100=200 页。

#### a.

```c
for (int j = 0; j < 100; j++)
	for (int i = 0; i < 100; i++)
		A[i][j] = 0;
```

**答：** 

> In this case, the array A is accessed row by row and thus each row generates 2 page faults as the first reference to a page always generates a page fault. Using LRU, it will generate 200 page faults.
>
> 在这种情况下，数组 A 被逐行访问，因此每行产生 2 个页面故障，因为对一个页面的第一次引用总是产生一个页面故障。使用 LRU，它将产生 200 个页面故障。

#### b.

```c
for (int i = 0; i < 100; i++)
    for (int j = 0; j < 100; j++)
    	A[i][j] = 0;
```

**答：** 

> In this case, the array A is accessed column by column and thus the process references 100 pages in each outside loop (I), which is the working set of the program. But we only have 2 frames, and thus each array reference will generate a page fault. Using LRU, it will generate 100 * 100 = 10,000 page faults.
>
>  在这种情况下，数组 A 被逐列访问，因此进程在每个外部循环（I）中引用了 100 个页面，这就是程序的工作集。但是我们只有 2 个框架，因此每个数组引用将产生一个页面故障。使用 LRU，它将产生 100*100=10,000 个页面故障。



> This example shows that a well-written program can be much faster than a program is not carefully written.
>
> 这个例子表明，一个写得好的程序可以比一个不仔细写的程序快得多。







### 9.8 Consider the following page reference string:

`1, 2, 3, 4, 2, 1, 5, 6, 2, 1, 2, 3, 7, 6, 3, 2, 1, 2, 3, 6.`

How many page faults would occur for the following replacement algorithms, assuming one, two, three, four, five, six, and seven frames? Remember that all frames are initially empty, so your first unique pages will cost one fault each.

假设有一个、两个、三个、四个、五个、六个和七个 frames，下列替换算法会发生多少个页面故障？记住，所有的 frames 最初都是空的，所以你的第一个独特的页面将花费每个故障。

- LRU replacement
- FIFO replacement
- Optimal replacement

**答：**

```
Number of frames		LRU			FIFO			Optimal
1						20			20				20
2						18			18				15
3						15			16				11
4						10			14				8
5						8			10				7
6						7			10				7
7						7			7				7
```









## Exercises

9.15, 9.18, 9.21, 9.22, 9.32, 9.34

### 9.15 A simplified view of thread states is Ready, Running, andBlocked, where a thread is either ready and waiting to be scheduled, is running on the processor, or is blocked (for example, waiting for I/O). This is illustrated in Figure 9.31. Assuming a thread is in the Running state, answer the following questions, and explain your answer:

线程状态的简化视图是就绪、运行和阻塞，其中线程要么就绪并等待被调度，要么在处理器上运行，要么被阻塞（例如，等待 I/O）。这在图 9.31 中得到了说明。假设一个线程处于运行状态，请回答下列问题，并解释你的答案。

![image-20210618151815957](http://framist-bucket-openread.oss-cn-shanghai.aliyuncs.com/img/2023/08/15/20230815203909-1.png)

#### a. Will the thread change state if it incurs a page fault? If so, to what state will it change? 

a. 如果线程发生了页面故障，它是否会改变状态？如果是的话，它将改变到什么状态？

**答：**

> Yes, a tread changes from the Running state to the Blocked state when a page fault occurs. When a page fault occurs, the process starts to wait for I/O operation to finish. 
>
> The OS checks whether the page is really invalid or just on disk, finds a free memory frame, schedules a disk access to load the page into t the frame, updates the page table with the new logical-physical mapping when disk I/O is completed, updates the valid bit of that entry, and eventually restarts the process by change its state from Blocked to Ready.
>
> 是的，当一个页面故障发生时，一个 tread 从运行状态变为阻塞状态。当一个页面故障发生时，进程开始等待 I/O 操作的完成。
> 操作系统检查该页是否真的无效或只是在磁盘上，找到一个空闲的内存帧，安排一次磁盘访问将该页加载到该帧中，当磁盘 I/O 完成后用新的逻辑 - 物理映射更新页表，更新该条目的有效位，并最终重新启动进程，将其状态从阻塞状态变为就绪状态。



#### b. Will the thread change state if it generates a TLBmiss that is resolved in the page table? If so, to what state will it change? 

b. 如果线程产生了一个在页表中被解决的 TLBmiss，它是否会改变状态？如果是的话，它将改变到什么状态？

**答：**

> Not necessarily. If a page table entry is not found in the TLB (TLB miss), the page number is used to index and process the page table. If the page is already in main memory, then TLB is updated to include the new page entry, while the process execution continues since there is no I/O operation needed. If the page is not in the main memory, a page fault is generated. In this case, the process needs to change to the Blocked state and wait for I/O to access the disk. This is the same procedure as in the first question.
>
> 不一定。如果在 TLB 中没有找到一个页表项（TLB 缺失），页号被用来索引和处理页表。如果该页已经在主内存中，那么 TLB 被更新以包括新的页条目，同时由于不需要 I/O 操作，进程继续执行。如果该页不在主存中，就会产生一个页故障。在这种情况下，进程需要改变为阻塞状态，等待 I/O 访问磁盘。这与第一个问题中的程序相同。



#### c. Will the thread change state if an address reference is resolved in the page table? If so, to what state will it change?

c. 如果一个地址引用在页表中被解决，线程是否会改变状态？如果是的话，它将会改变到什么状态？

**答：**

> No, because no I/O operation is needed is the address reference is resolved in the page table, which indicates the page needed is loaded in the main memory already.
>
> 不，因为不需要 I/O 操作，因为地址引用在页表中被解决了，这表明需要的页已经加载在主存中。











### 9.18 A certain computer provides its users with a virtual memory space of $2^{32}$ bytes. The computer has $2^{22}$ bytes of physical memory. The virtual memory is implemented by paging, and the page size is 4,096 bytes. A user process generates the virtual address 11123456. Explain how the system establishes the corresponding physical location. Distinguish between software and hardware operations.

某台计算机为其用户提供了一个$2^{32}$字节的虚拟内存空间。该计算机有$2^{22}$字节的物理内存。虚拟内存是通过分页实现的，分页大小为 4,096 字节。一个用户进程产生了虚拟地址 11123456。解释一下系统如何建立相应的物理位置。区分软件和硬件的操作。

**答：**

> The virtual address in binary form is
>
> 0001 0001 0001 0010 0011 0100 0101 0110
>
> Since the page size is 2^12, the page table size is 2^20. Therefore the low order 12 bits 0100 0101 0110 are used as the displacement into the page, while the remaining 20 bits 0001 0001 0001 0010 0011 are used as the displacement in the page table. The offset bits are then concatenated to the resulting physical page number (from the page table), to form the final address.
>
> 由于页面大小为 2^12，所以页表大小为 2^20。因此，低阶的 12 位 0100 0101 0110 被用作进入页面的位移，而剩下的 20 位 0001 0001 0001 0010 0011 被用作页表的位移。然后将偏移位与产生的物理页号（来自页表）相连接，形成最终地址。



### 9.21 Consider the following page reference string:

`7, 2, 3, 1, 2, 5, 3, 4, 6, 7, 7, 1, 0, 5, 4, 6, 2, 3, 0 , 1.`

Assuming demand paging with three frames, how many page faults would occur for the following replacement algorithms?

假设有三个框架的需求分页，对于下面的替换算法，会出现多少个页面故障？

#### LRU replacement

**答：** 18

#### FIFO replacement

**答：** 17

#### Optimal replacement

**答：** 13





### 9.22 The page table shown in Figure 9.32 is for a system with 16-bit virtual and physical addresses and with 4,096-byte pages. The reference bit is set to 1 when the page has been referenced. Periodically, a thread zeroes out all values of the reference bit. A dash for a page frame indicates the page is not in memory. The page-replacement algorithm is localized LRU, and all numbers are provided in decimal.

图 9.32 所示的页表是针对一个具有 16 位虚拟和物理地址的系统和 4,096 字节的页。当页面被引用时，参考位被设置为 1。定期地，一个线程会将参考位的所有值清零。一个页框的破折号表示该页不在内存中。页面替换算法是本地化的 LRU，所有数字都以十进制提供。

#### a. Convert the following virtual addresses (in hexadecimal) to the equivalent physical addresses. You may provide answers in either

将下列虚拟地址（十六进制）转换成相应的物理地址。你可以用以下两种方式提供答案



![image-20210616125759526](http://framist-bucket-openread.oss-cn-shanghai.aliyuncs.com/img/2023/08/15/20230815203909-2.png)

<center>Figure 9.32 Page table for Exercise 9.22.</center>

hexadecimal or decimal. Also set the reference bit for the appropriate entry in the page table.

十六进制或十进制。同时为页表中的适当条目设置参考位。


- `0xE12C`
- `0x3A9D`
- `0xA9D9`
- `0x7001`
- `0xACA1`

**答：**

- `0xE12C` -> `0x312C`
- `0x3A9D` -> `0xAA9D`
- `0xA9D9` -> `0x59D9`
- `0x7001` -> `0xF001`
- `0xACA1` -> `0x5CA1`



#### b. Using the above addresses as a guide, provide an example of a logical address (in hexadecimal) that results in a page fault.

以上述地址为指导，提供一个导致页面故障的逻辑地址（十六进制）的例子。

**答：**

`0x4...`



#### c. From what set of page frames will the LRU page-replacement algorithm choose in resolving a page fault?

在解决一个页面故障时，LRU 页面替换算法将从哪一组页面框架中选择？

**答：**

{9,1,14,13,8,0,4,2}







### 9.32 What is the cause of thrashing? How does the system detect thrashing? Once it detects thrashing, what can the system do to eliminate this problem?

系统抖动的原因是什么？系统是如何检测系统抖动的？一旦检测到系统抖动，系统可以做什么来消除这个问题？

**答：** 

抖动是因为调用系统与 CPU 调度程序某些功能的冲突造成。

> The operating system monitors CPU utilization. If CPU utilization is too low, we increase the degree of multiprogramming by introducing a new process to the system. A global page-replacement algorithm is used; it replaces pages without regard to the process to which they belong. Now suppose that a process enters a new phase in its execution and needs more frames. It starts faulting and taking frames away from other processes. These processes need those pages, however, and so they also fault, taking frames from other processes. These faulting processes must use the paging device to swap pages in and out. As they queue up for the paging device, the ready queue empties. As processes wait for the paging device, CPU utilization decreases. The CPU scheduler sees the decreasing CPU utilization and increases the degree of multiprogramming as a result. The new process tries to get started by taking frames from running processes, causing more page faults and a longer queue for the paging device. As a result, CPU utilization drops even further, and the CPU scheduler tries to increase the degree of multiprogramming even more. Thrashing has occurred, and system throughput plunges. The pagefault rate increases tremendously. As a result, the effective memory-access time increases. No work is getting done, because the processes are spending all their time paging.
>
> ————教材 P426



> Thrashing is caused by under allocation of the minimum number of pages required by a process, forcing it to continuously page fault. The system can detect thrashing by evaluating the level of CPU utilization as compared to the level of multiprogramming. It can be eliminated by reducing the level of multiprogramming.
>
> 抖动是由于进程所需的最小页数分配不足而造成的，迫使它不断出现页面故障。系统可以通过评估 CPU 的利用率与多程序化水平的比较来检测阻塞。它可以通过减少多程序的水平来消除。

### 9.34 Consider the parameter △ used to define the working-set window in the working-set model. When △ is set to a small value, what is the effect on the page-fault frequency and the number of active (nonsuspended) processes currently executing in the system? What is the effect when △ is set to a very high value?

考虑用于定义工作集模型中工作集窗口的参数△。当△被设置为一个小值时，对页面故障频率和当前在系统中执行的活动（非暂停）进程的数量有什么影响？当△被设置为一个非常高的值时，会有什么影响？

**答：**

> When set to a smaller value, it is possible to underestimate the set of resident pages of a process, allowing a process to be arranged, even if all the pages it needs are not hosted. This can result in a large number of page errors. 
>
> When set to a larger value, overestimating the resident set of a process may prevent many processes from being scheduled, even though the pages they need reside. However, once a process is scheduled, it is not possible to generate a page fault when overestimating the resident set
>
> 当设置为一个较小的值时，有可能低估一个进程的驻留页集，允许一个进程被安排，即使它所需要的所有页面没有被托管。这可能导致大量的页面错误。
> 当设置为一个较大的值时，高估一个进程的驻留集可能会阻止许多进程被安排，即使它们需要的页面驻留了。然而，一旦一个进程被调度，当高估驻留集时，就不可能产生一个页面错误




---

**注：**

翻译：deepl

参考资料：

[1] Operating System Concepts – 9th Edition 与 其参考答案

